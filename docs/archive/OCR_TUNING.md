# レシートOCR読み取り精度向上 - 実装プラン

## 概要

レシートOCR読み取りの精度向上を図るため、3段階のアプローチで実装します。

### 問題点
- レシートに記載されている内容が、食材以外の項目も多い
  - 例: 「じゃがいもバラ」→「じゃがいも」で良い（「バラ」は不要）
  - 例: 「生しいたけ大」→「しいたけ」で良い（「生」「大」は不要）
  - 例: 「新ＢＰコクのある絹豆腐」→「豆腐」で良い（商品名は不要）
  - 例: 「ＢＰ成分無調整牛乳」→「牛乳」で良い（商品名は不要）
  - 例: 「悠々鶏モモ肉国産」→「鶏もも肉」で良い
  - 例: 「もっちり仕込み」→「食パン」としたい（商品名から食パンと解らない）

### 解決アプローチ

1. **画像LLM解析プロンプトの改善**: プロンプトを工夫して、食材名だけ抽出するようにする
2. **パターンマッチング**: LLMからの返却後、不要な文言を削除する処理を追加
3. **変換テーブル**: ユーザーがOCR読み取り編集時に変換したら、自動的に変換テーブルに追加

---

## 実装方針

### デグレード防止の原則

1. **既存機能への影響を最小化**
   - 既存のAPIインターフェースは変更しない
   - 既存のレスポンス形式は維持
   - 後方互換性を保つ

2. **段階的な実装**
   - 各段階を独立して実装・テスト可能にする
   - 各段階でロールバック可能にする
   - 機能フラグで有効/無効を切り替え可能にする

3. **テスト可能な単位での分割**
   - 各機能を独立してテストできるようにする
   - 既存のテストが壊れないようにする

4. **エラーハンドリングの強化**
   - 新機能が失敗しても既存機能は動作する
   - ログを詳細に記録して問題を追跡可能にする

---

## 実装詳細

### 段階1: 画像LLM解析プロンプトの改善

#### 目的
プロンプトを改善して、LLMが食材名のみを抽出するようにする。

#### 実装内容

**修正ファイル**: `services/ocr_service.py`

**修正箇所**: `analyze_receipt_image` メソッド（56-76行目）

**修正内容**:
- プロンプトに「食材名のみ抽出」の指示を追加
- 商品名・ブランド名・サイズ表記（大/小/バラ等）を除外する指示を追加
- 具体例を明示

**修正前のプロンプト**:
```
このレシート画像から、在庫管理に必要な情報を抽出してください。

抽出すべき情報:
- 商品名（item_name）
- 数量（quantity）
- 単位（unit）
- 保管場所（storage_location、推測可）
- 消費期限（expiry_date、もし記載されていれば）

レスポンス形式: JSON配列
[
  {
    "item_name": "商品名",
    "quantity": 数量,
    "unit": "単位",
    "storage_location": "保管場所",
    "expiry_date": "YYYY-MM-DD または null"
  }
]

日本語のレシートを正確に解析してください。商品名は正確に、数量と単位も正しく抽出してください。
```

**修正後のプロンプト**:
```
このレシート画像から、在庫管理に必要な食材情報を抽出してください。

【重要】item_nameには、食材名のみを抽出してください。
以下の情報は除外してください：
- ブランド名（例: 「新ＢＰ」「ＢＰ」など）
- 商品名・商品説明（例: 「コクのある」「成分無調整」など）
- サイズ表記（例: 「大」「小」「中」「バラ」など）
- 状態表記（例: 「生」「国産」など、ただし食材の種類を特定するために必要な場合は除く）

【良い例】
- 「じゃがいもバラ」→「じゃがいも」
- 「生しいたけ大」→「しいたけ」
- 「新ＢＰコクのある絹豆腐」→「豆腐」
- 「ＢＰ成分無調整牛乳」→「牛乳」
- 「悠々鶏モモ肉国産」→「鶏もも肉」

【悪い例】
- 「じゃがいもバラ」→「じゃがいもバラ」（「バラ」は不要）
- 「新ＢＰコクのある絹豆腐」→「新ＢＰコクのある絹豆腐」（商品名は不要）

抽出すべき情報:
- 商品名（item_name）: 食材名のみ（上記の除外ルールに従う）
- 数量（quantity）
- 単位（unit）
- 保管場所（storage_location、推測可）
- 消費期限（expiry_date、もし記載されていれば）

レスポンス形式: JSON配列
[
  {
    "item_name": "食材名",
    "quantity": 数量,
    "unit": "単位",
    "storage_location": "保管場所",
    "expiry_date": "YYYY-MM-DD または null"
  }
]

日本語のレシートを正確に解析してください。食材名は簡潔に、数量と単位も正しく抽出してください。
```

**影響範囲**:
- `services/ocr_service.py` のみ修正
- 既存のAPIインターフェースは変更なし
- 既存のテストは影響なし（プロンプト変更のみ）

**テスト方法**:
- 既存のOCRテストを実行して、既存機能が動作することを確認
- 新しいプロンプトで実際のレシート画像をテスト

**ロールバック方法**:
- プロンプトを元に戻すだけ

---

### 段階2: パターンマッチングによる後処理

#### 目的
LLMからの返却後、正規表現パターンで不要な文言を削除する。

#### 実装内容

**修正ファイル**: `services/ocr_service.py`

**新規メソッド追加**: `normalize_item_name` メソッド

**実装内容**:
1. 正規表現パターンで不要な文言を削除
   - サイズ表記: 「バラ」「大」「小」「中」など
   - 状態表記: 「生」「国産」「成分無調整」など（ただし食材の種類を特定するために必要な場合は除く）
   - ブランド名: 「新ＢＰ」「ＢＰ」など（一般的なブランド名のパターン）
   - 商品説明: 「コクのある」「もっちり」など（一般的な商品説明のパターン）

2. `analyze_receipt_image` メソッドの結果に適用

**実装例**:
```python
def normalize_item_name(self, item_name: str) -> str:
    """
    商品名を正規化して食材名のみを抽出
    
    Args:
        item_name: OCRで読み取られた商品名
        
    Returns:
        正規化された食材名
    """
    if not item_name:
        return item_name
    
    normalized = item_name.strip()
    
    # サイズ表記を削除（末尾）
    size_patterns = [
        r'\s*バラ\s*$',
        r'\s*大\s*$',
        r'\s*小\s*$',
        r'\s*中\s*$',
        r'\s*特大\s*$',
        r'\s*特小\s*$',
    ]
    for pattern in size_patterns:
        normalized = re.sub(pattern, '', normalized, flags=re.IGNORECASE)
    
    # 状態表記を削除（先頭・末尾）
    state_patterns = [
        r'^生\s*',
        r'^国産\s*',
        r'\s*国産\s*$',
        r'^成分無調整\s*',
        r'\s*成分無調整\s*$',
    ]
    for pattern in state_patterns:
        normalized = re.sub(pattern, '', normalized, flags=re.IGNORECASE)
    
    # ブランド名を削除（先頭）
    brand_patterns = [
        r'^新ＢＰ\s*',
        r'^ＢＰ\s*',
        r'^新\s*',
    ]
    for pattern in brand_patterns:
        normalized = re.sub(pattern, '', normalized, flags=re.IGNORECASE)
    
    # 商品説明を削除（中間・末尾）
    description_patterns = [
        r'\s*コクのある\s*',
        r'\s*もっちり\s*',
        r'\s*仕込み\s*',
    ]
    for pattern in description_patterns:
        normalized = re.sub(pattern, '', normalized, flags=re.IGNORECASE)
    
    # 余分な空白を削除
    normalized = re.sub(r'\s+', ' ', normalized).strip()
    
    return normalized
```

**適用箇所**:
- `analyze_receipt_image` メソッド内で、JSON解析後に各アイテムの `item_name` に適用

**影響範囲**:
- `services/ocr_service.py` のみ修正
- 既存のAPIインターフェースは変更なし
- 既存のテストは影響なし（後処理追加のみ）

**テスト方法**:
- 正規化メソッドのユニットテストを作成
- 既存のOCRテストを実行して、既存機能が動作することを確認
- 実際のレシート画像でテスト

**ロールバック方法**:
- 正規化メソッドの呼び出しをコメントアウト

---

### 段階3: 変換テーブルの実装

#### 目的
ユーザーがOCR読み取り編集時に変換したら、自動的に変換テーブルに追加する。

#### 実装内容

##### 3-1. データベーステーブル作成

**ファイル**: `docs/archive/DDL.md`（既に追加済み）

**テーブル**: `ocr_item_mappings`
- `id`: UUID（主キー）
- `user_id`: UUID（ユーザーID、外部キー）
- `original_name`: VARCHAR(255)（OCRで読み取られた元の名前）
- `normalized_name`: VARCHAR(255)（正規化後の名前）
- `created_at`: TIMESTAMP
- `updated_at`: TIMESTAMP
- `UNIQUE(user_id, original_name)`: 同一ユーザー内で元の名前は一意

**実行手順**:
1. Supabaseダッシュボード → SQL Editor
2. `docs/archive/DDL_ocr.md` のSQLを実行

##### 3-2. CRUDサービスの作成

**新規ファイル**: `mcp_servers/ocr_mapping_crud.py`

**実装内容**:
- `add_mapping`: 変換テーブルに登録
- `get_mapping`: 変換テーブルから取得
- `get_all_mappings`: ユーザーの全変換テーブルを取得
- `update_mapping`: 変換テーブルを更新
- `delete_mapping`: 変換テーブルを削除

**実装パターン**: `mcp_servers/inventory_crud.py` を参考にする

##### 3-3. OCRServiceへの変換テーブル適用機能追加

**修正ファイル**: `services/ocr_service.py`

**新規メソッド追加**: `apply_item_mappings` メソッド

**実装内容**:
- ユーザーIDとSupabaseクライアントを受け取る
- OCR結果の各アイテムの `item_name` を変換テーブルで検索
- マッチする場合は `normalized_name` に置き換え

**適用箇所**:
- `analyze_receipt_image` メソッド内で、正規化処理の後に適用
- ただし、Supabaseクライアントが必要なため、API層から呼び出す

##### 3-4. APIエンドポイントの修正

**修正ファイル**: `api/routes/inventory.py`

**修正箇所**: `ocr_receipt` エンドポイント

**修正内容**:
1. Supabaseクライアントを取得
2. OCRServiceの `analyze_receipt_image` を呼び出し
3. 変換テーブルを適用（`apply_item_mappings` メソッドを呼び出し）
4. 既存の処理を継続

##### 3-5. 変換テーブル登録APIエンドポイントの追加

**新規エンドポイント**: `POST /api/inventory/ocr-mapping`

**実装内容**:
- リクエスト: `original_name`, `normalized_name`
- レスポンス: 登録結果

**リクエストモデル**:
```python
class OCRMappingRequest(BaseModel):
    original_name: str = Field(..., description="OCRで読み取られた元の名前")
    normalized_name: str = Field(..., description="正規化後の名前")
```

**レスポンスモデル**:
```python
class OCRMappingResponse(BaseModel):
    success: bool
    message: str
    mapping_id: Optional[str] = None
```

##### 3-6. フロントエンド修正（別セッションで実装）

**実装内容**:
- OCR編集時に、元の名前と編集後の名前が異なる場合、自動的に変換テーブルに登録
- `POST /api/inventory/ocr-mapping` を呼び出す

**注意**: フロントエンドの実装は別セッションで行う

**影響範囲**:
- 新規DBテーブル追加（マイグレーション必要）
- `services/ocr_service.py` 修正
- `api/routes/inventory.py` 修正
- `api/models/requests.py` 修正（新規モデル追加）
- `mcp_servers/ocr_mapping_crud.py` 新規作成

**テスト方法**:
- CRUDサービスのユニットテスト
- APIエンドポイントの統合テスト
- 既存のOCRテストを実行して、既存機能が動作することを確認

**ロールバック方法**:
- 変換テーブル適用処理をコメントアウト
- 新規APIエンドポイントを無効化

---

## 実装順序とセッション分割

### セッション分割の考え方

各セッションは**1〜2時間程度**で完了できるサイズに分割しています。
これにより、1セッションのコンテキストウィンドウで処理しきれるサイズになっています。

### セッション概要

| セッション | 内容 | 所要時間 | リスク | 依存関係 |
|----------|------|---------|--------|---------|
| セッション1 | プロンプト改善 | 30分〜1時間 | 低 | なし |
| セッション2 | パターンマッチング | 1〜2時間 | 低 | セッション1 |
| セッション3A | DBとCRUDサービス | 1〜1.5時間 | 低 | なし |
| セッション3B | API統合 | 1.5〜2時間 | 中 | セッション3A |
| セッション4 | フロントエンド | 1〜2時間 | 低 | セッション3B |

**セッションの依存関係**:
- セッション1: 独立（他のセッションに依存しない）
- セッション2: セッション1に依存（プロンプト改善の後に実装）
- セッション3A: 独立（データベースとCRUDサービスのみ）
- セッション3B: セッション3Aに依存（CRUDサービスが必要）
- セッション4: セッション3Bに依存（APIエンドポイントが必要）

**推奨実装順序**:
1. セッション1 → セッション2（段階1と2を連続で実装）
2. セッション3A → セッション3B（段階3を連続で実装）
3. セッション4（フロントエンドは別セッションで実装）

---

### セッション1: 段階1の実装（プロンプト改善）

**作業内容**:
1. `services/ocr_service.py` のプロンプトを修正
2. 既存のOCRテストを実行して確認
3. 実際のレシート画像でテスト

**所要時間**: 30分〜1時間

**リスク**: 低（プロンプト変更のみ）

**ロールバック**: 簡単（プロンプトを元に戻すだけ）

---

### セッション2: 段階2の実装（パターンマッチング）

**作業内容**:
1. `services/ocr_service.py` に `normalize_item_name` メソッドを追加
2. `analyze_receipt_image` メソッドで正規化処理を適用
3. 正規化メソッドのユニットテストを作成
4. 既存のOCRテストを実行して確認
5. 実際のレシート画像でテスト

**所要時間**: 1〜2時間

**リスク**: 低（後処理追加のみ）

**ロールバック**: 簡単（正規化処理の呼び出しをコメントアウト）

---

### セッション3A: 段階3の実装（変換テーブル - データベースとCRUD）

**作業内容**:
1. データベーステーブル作成（`DDL_ocr.md` のSQLを実行）
2. `mcp_servers/ocr_mapping_crud.py` を作成
   - `add_mapping`: 変換テーブルに登録
   - `get_mapping`: 変換テーブルから取得
   - `get_all_mappings`: ユーザーの全変換テーブルを取得
   - `update_mapping`: 変換テーブルを更新
   - `delete_mapping`: 変換テーブルを削除
3. CRUDサービスのユニットテストを作成
4. データベース接続とRLSポリシーの確認

**所要時間**: 1〜1.5時間

**リスク**: 低（データベースとCRUDサービスのみ）

**ロールバック**: 簡単（CRUDサービスを無効化、テーブルは残す）

**依存関係**: なし（独立して実装可能）

---

### セッション3B: 段階3の実装（変換テーブル - API統合）

**作業内容**:
1. `services/ocr_service.py` に `apply_item_mappings` メソッドを追加
2. `api/routes/inventory.py` の `ocr_receipt` エンドポイントを修正
   - Supabaseクライアントを取得
   - OCR結果に変換テーブルを適用
3. `api/models/requests.py` に新規モデルを追加
   - `OCRMappingRequest`
   - `OCRMappingResponse`
4. `POST /api/inventory/ocr-mapping` エンドポイントを追加
5. APIエンドポイントの統合テストを作成
6. 既存のOCRテストを実行して確認

**所要時間**: 1.5〜2時間

**リスク**: 中（API修正と統合）

**ロールバック**: 中（変換テーブル適用処理をコメントアウト、新規APIエンドポイントを無効化）

**依存関係**: セッション3A（CRUDサービスが必要）

---

### セッション4: 段階3の実装（変換テーブル - フロントエンド）

**作業内容**:
1. OCR編集時に、元の名前と編集後の名前が異なる場合を検出
2. `POST /api/inventory/ocr-mapping` を呼び出して変換テーブルに登録
3. フロントエンドのテスト

**所要時間**: 1〜2時間

**リスク**: 低（フロントエンドのみ）

**ロールバック**: 簡単（変換テーブル登録処理をコメントアウト）

**注意**: フロントエンドの実装は別セッションで行う

---

## テスト計画

### ユニットテスト

1. **正規化メソッドのテスト**（段階2）
   - 各種パターンのテストケースを作成
   - 期待値と実際の値を比較

2. **CRUDサービスのテスト**（段階3）
   - 各CRUD操作のテスト
   - エラーハンドリングのテスト

### 統合テスト

1. **OCRエンドポイントのテスト**
   - 既存のOCRテストを実行
   - 新機能が既存機能に影響しないことを確認

2. **変換テーブルAPIのテスト**（段階3）
   - 登録・取得・更新・削除のテスト

### 手動テスト

1. **実際のレシート画像でのテスト**
   - 各段階で実際のレシート画像をテスト
   - 精度向上を確認

---

## デグレード防止チェックリスト

### 各セッションで確認すること

- [ ] 既存のOCRテストが全て通過する
- [ ] 既存のAPIエンドポイントが正常に動作する
- [ ] 既存のレスポンス形式が維持されている
- [ ] エラーハンドリングが適切に実装されている
- [ ] ログが適切に記録されている

### 段階3（セッション3A）で追加で確認すること

- [ ] データベースマイグレーションが正常に完了する
- [ ] RLSポリシーが適切に設定されている
- [ ] CRUDサービスが正常に動作する
- [ ] ユニットテストが全て通過する

### 段階3（セッション3B）で追加で確認すること

- [ ] 変換テーブルが空でも既存機能が動作する
- [ ] 変換テーブルの適用が失敗しても既存機能が動作する
- [ ] 新規APIエンドポイントが正常に動作する
- [ ] 既存のOCRエンドポイントが正常に動作する

---

## ロールバック手順

### 段階1のロールバック

1. `services/ocr_service.py` のプロンプトを元に戻す

### 段階2のロールバック

1. `services/ocr_service.py` の正規化処理の呼び出しをコメントアウト

### 段階3のロールバック

1. `api/routes/inventory.py` の変換テーブル適用処理をコメントアウト
2. `POST /api/inventory/ocr-mapping` エンドポイントを無効化（コメントアウト）
3. データベーステーブルは残しておく（データ保持のため）

---

## 今後の拡張案

1. **変換テーブルの管理UI**
   - ユーザーが変換テーブルを確認・編集・削除できるUI

2. **変換テーブルの共有機能**
   - よく使われる変換を共有できる機能

3. **機械学習による自動変換**
   - 変換テーブルのデータを学習して、自動的に変換を提案

---

## 参考資料

- `docs/archive/DDL.md`: データベース設計
- `docs/archive/DDL_ocr.md`: OCR変換テーブルのDDL
- `services/ocr_service.py`: OCRサービスの実装
- `api/routes/inventory.py`: 在庫管理API
- `mcp_servers/inventory_crud.py`: 在庫管理CRUDの実装パターン

