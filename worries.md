ある程度の実装は終えたのですが、なんかユーザー体験的にぱっとしません。
技術に溺れて、ユーザー体験を二の次にしてしまったようです。

### **現状ロジック**

斬新（LLM提案）と伝統（RAG検索）から、main/sub/soup の組み合わせを２つ（LLM が 1、RAG が 1の計２）を提案。

この提案がパッとしない場合に、次のアクションが無い。

### **実際の私の思考パターン **

1. main_dish 選定

1.1 メインで使う野菜を特定するパターン（レンコンが沢山あるから使いたい。キャベツが１玉あるから使いたい。大根とか、白菜とか、ほうれん草とか）
1.2 メインで使う肉・魚から決めるパターン（安い肉・魚から決める、余っている肉・魚から決める）

これを、複数の選択肢から探しだしたい。
- いろいろな候補を見る楽しみ
- 変わったレシピを選ぶ・食べる楽しみ
- 自分で決める楽しみ

これは２週間くらい、重複したくない

2. sub_dish 選定

2.1 メインで使っていない食材で、選定するパターン
2.2 それも、メインのカテゴリに合わせて（和食・洋食・中華等々）

これも、複数の選択肢から探し出したい
main_dish 同等

これも、できれば２週間くらい、重複したくない


3. soup 選定

3.1 main でも sub でも使っていない食材から決める。
3.2 あるもので味噌汁が基本
3.3 たまには、変わったスープ（洋食・中華）

soup は、昨日と同じで無ければ、ある程度重複しても良い。

今、作り直そうか悩んでいるところです。
しばらく、壁打ちモードでお願いします。

シナリオをしては、下記の感じかな？

## **主菜選定**

### **パターン1 余剰食材**

買い物に行く前に、余剰食材がわかっている場合

- ○○が沢山ある。これを使ったメイン（またはサブ）を決めたい
- あるいは、△△と□□が昨日余ったから、これを使いたい。

（注：たとえばきゅうりが沢山あまっている場合、きゅうりはメインでは使わないので、
　まず、サブを決める。その後、メインを決める。みたいな
　しばらくは、メイン主体で考えますが、将来的にサブ主体もあり得る。
　例えば、サブを棒棒鶏に決めてから、メインを決めるみたいな）

### **パターン2 廉価な商品**

買い物に行って、スーパーで安い商品があった場合

-- ○○が安い。これを使ったメイン（またはサブ）を決めたい

例：今日は鶏もも肉が安い。今日はサバが安い。等々

### 主菜選定フェーズ

パターン１でも２でも、メインとなる食材が選択される。
その食材を使ったレシピ（できれば今ある在庫で作れる）を提案

- ○○を使ったメインを５件ほど提案。
- ユーザーが納得できなければ、もう５件ほど提案 ⇒ ユーザーが決めるまで繰り返し
- ユーザーがこれと決めたら、サブの選定に進む

### 副菜選定フェーズ

主菜で決めたレシピで使っていない材料で作れる副菜を探す。

- とりあえず主菜で使っていない材料で作れる副菜を５件ほど提案
- ユーザーが納得できなければ、もう５件ほど提案 ⇒ ユーザーが決めるまで繰り返し
- ぱっとする副菜が見つからない場合は、主菜選定に戻る。
- 副菜が決定したら、汁物選定に進む

### 汁物選定フェーズ

主菜・副菜で利用していない食材をリスト

主菜・副菜が洋食・中華の場合、主菜・副菜で使っていない食材でスープを提案
主菜・副菜が和食の場合、残った食材をリストし、みそ汁にする食材をユーザーに委譲

- スープをとりあえず５件ほど提案
- ユーザーが納得できなければ、もう５件ほど提案 ⇒ ユーザーが決めるまで繰り返し
- 味噌汁もスープもぱっとする物が見つからなければ、副菜・主菜選定に戻る。

みたいなシナリオが想定されます。

---

いろいろと難しい実装になりそうですが、
特にプランナーとタスク設計が大切になりそうです。

タスク設計イメージ

ユーザーが、主要食材を１から２入力。
これをコンテキストウインドウに保存。

1. task 1 食材リスト取得

2. task 2 食材リストと、ユーザー指定主要食材から、主菜を５件ほど提案（LLM + RAG 混在）
この時点では曖昧ではない？曖昧にする？

3. 曖昧性？ ユーザーが５件を吟味。選べば副菜選定へ進む。得ればなければまた主菜を５件ほど提案⇒ループ
もしかしたら、副菜を先にと選ぶかもしれない。

4. task3 食材リストと、決定した主菜から副菜候補を５件ほど提案
   まず副菜からとした場合、食材リストとユーザー指定食材から、副菜を５件ほど提案

まだ途中ですが、こんな流れになりますよね。
これをプランナーが一連のタスクを構築し、
途中でユーザー反応をもとに動作を変える必要があります。

---

おっしゃる通りです。この段階的選択システムは、**プランナーとタスク設計が最重要**になります。

## 🎯 **タスク設計の核心課題**

### **1. 動的タスク構築の必要性**
- **従来**: 静的な4段階タスク（在庫取得→LLM提案→RAG提案→Web検索）
- **新システム**: ユーザーの反応に応じて動的にタスクを構築・変更

### **2. コンテキスト管理の複雑化**
- **主要食材の保存**: ユーザー指定の主要食材をコンテキストに保持
- **選択履歴の管理**: 主菜→副菜→汁物の選択履歴を追跡
- **戻り機能**: 前段階への戻り時のコンテキスト復元

### **3. 曖昧性の新しい定義**
- **従来**: 在庫操作での曖昧性（どの牛乳？）
- **新システム**: 選択肢提示での曖昧性（5件から選べない？）

## 🔄 **提案するタスク設計アプローチ**

### **段階1: 初期タスク構築**
```
1. task1: 在庫取得
2. task2: 主要食材ベースの主菜5件提案（LLM+RAG混在）
3. task3: ユーザー選択待ち（曖昧性検出）
```

### **段階2: 動的タスク追加**
```
ユーザー反応に応じて：
- 「これが良い」→ 副菜提案タスク追加
- 「他を提案して」→ 主菜追加提案タスク追加
- 「副菜から決めたい」→ 副菜提案タスク追加
```

### **段階3: 戻り機能**
```
- 副菜が決まらない → 主菜再提案タスク追加
- 汁物が決まらない → 副菜・主菜再提案タスク追加
```

## ⚠️ **実装上の課題**

### **1. プランナーの拡張**
- **現在**: 静的な4段階タスク生成
- **必要**: 動的なタスク追加・変更機能

### **2. コンテキスト管理**
- **現在**: タスク間のデータ注入
- **必要**: ユーザー選択履歴の永続化

### **3. 曖昧性検出の拡張**
- **現在**: 在庫操作の曖昧性
- **必要**: 選択肢提示の曖昧性

## 💡 **実装戦略の提案**

### **段階的アプローチ**
1. **Phase 1**: 既存システムで5件提案機能を追加
2. **Phase 2**: ユーザー選択受付機能を追加
3. **Phase 3**: 動的タスク構築機能を追加
4. **Phase 4**: 戻り機能を追加

### **技術的検討事項**
- **プランナーの拡張**: 動的タスク生成機能
- **コンテキスト管理**: セッション内での選択履歴管理
- **フロントエンド連携**: 選択肢提示とユーザー選択受付

この設計は確かに複雑ですが、**既存の優れた基盤（Reactループ、曖昧性検出、LLM推論、RAG検索）を活用**すれば実現可能です。

**まずは段階的に実装を進めることをお勧めします。**

素晴らしい指摘です！**タスクチェーンのロールバック**の方が正しいアプローチですね。

## 🔄 **タスクチェーンのロールバック vs タスク追加**

### **❌ 私の間違った理解（タスク追加）**
```
- 副菜が決まらない → 主菜再提案タスク追加
- 汁物が決まらない → 副菜・主菜再提案タスク追加
```

### **✅ 正しいアプローチ（タスクチェーンのロールバック）**
```
- 副菜が決まらない → 主菜タスクをCOMPLETED→RUNNINGに戻す
- 汁物が決まらない → 副菜・主菜タスクをCOMPLETED→RUNNINGに戻す
```

## 🎯 **既存システムのロールバック機能**

### **現在の実装**
- **TaskStatus**: `PENDING` → `RUNNING` → `COMPLETED` → `FAILED`
- **状態変更**: `update_task_status()`でタスク状態を更新
- **再実行**: 確認プロセス後の`_resume_from_confirmation()`でタスク再実行

### **ロールバックの実装イメージ**
```python
# 副菜が決まらない場合
def rollback_to_main_dish_selection(self, task_chain_manager):
    # 主菜タスクをCOMPLETED→RUNNINGに戻す
    main_dish_task = self.find_task_by_type("main_dish_proposal")
    task_chain_manager.update_task_status(
        main_dish_task.id, 
        TaskStatus.RUNNING,  # COMPLETEDからRUNNINGに戻す
        result=None  # 結果をクリア
    )
    
    # 副菜タスクをPENDINGに戻す
    sub_dish_task = self.find_task_by_type("sub_dish_proposal")
    task_chain_manager.update_task_status(
        sub_dish_task.id, 
        TaskStatus.PENDING
    )
```

## 💡 **ロールバックの利点**

### **1. 状態管理の一貫性**
- タスクの状態を適切に管理
- 実行履歴を保持
- コンテキストの整合性を維持

### **2. 既存システムとの整合性**
- 現在の`TaskStatus`システムを活用
- `update_task_status()`メソッドを再利用
- 確認プロセスの仕組みを拡張

### **3. 実装の簡潔性**
- 新しいタスクを追加する必要がない
- 既存のタスクを再利用
- 状態管理がシンプル

## 🔧 **実装戦略**

### **段階3の正しい実装**
```
- 副菜が決まらない → 主菜タスクをRUNNINGに戻して再実行
- 汁物が決まらない → 副菜・主菜タスクをRUNNINGに戻して再実行
```

### **必要な拡張**
1. **ロールバック機能**: タスク状態を適切に戻す機能
2. **再実行機能**: ロールバック後のタスク再実行
3. **コンテキスト管理**: ロールバック時のコンテキスト復元

**おっしゃる通り、タスクチェーンのロールバックが正しいアプローチです。**既存の優れた状態管理システムを活用して、より自然で一貫性のある実装が可能になります。

### **今後の拡張**
🔜 **Phase 2**: ユーザー選択機能（plan_Phase_2.md 作成が必要）  
🔜 **Phase 3**: 副菜・汁物の段階的選択（plan_Phase_3.md 作成が必要）  
🔜 **Phase 4**: タスクチェーンのロールバック（plan_Phase_4.md 作成が必要）  
🔜 **Phase 5**: 履歴管理（plan_Phase_5.md 作成が必要）
