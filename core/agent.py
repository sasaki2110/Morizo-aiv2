"""
TrueReactAgent: Main orchestrator for the core layer.

This component coordinates the entire ReAct loop, managing task planning,
execution, and response generation.
"""

import logging
from typing import Optional, Dict, Any
from .models import TaskChainManager, ExecutionResult
from .planner import ActionPlanner
from .executor import TaskExecutor
from .service_coordinator import ServiceCoordinator
from .exceptions import CoreError
from services.confirmation_service import ConfirmationService
from services.llm_service import LLMService
from config.loggers import GenericLogger


class ResponseFormatter:
    """Formats final responses using LLM."""
    
    def __init__(self):
        self.logger = GenericLogger("core", "response_formatter")
        self.llm_service = LLMService()
    
    async def format(self, execution_results: dict, sse_session_id: str = None) -> tuple[str, Optional[Dict[str, Any]]]:
        """Format execution results into natural language response."""
        try:
            # Use LLM service to format the response
            response, menu_data = await self.llm_service.format_response(execution_results, sse_session_id)
            self.logger.info(f"üîç [ResponseFormatter] Menu data received: {menu_data is not None}")
            if menu_data:
                self.logger.info(f"üìä [ResponseFormatter] Menu data size: {len(str(menu_data))} characters")
            return response, menu_data
        except Exception as e:
            logger = GenericLogger("core", "response_formatter")
            logger.error(f"Response formatting failed: {str(e)}")
            return f"„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„Åå„ÄÅ„É¨„Çπ„Éù„É≥„Çπ„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: {str(e)}", None


class TrueReactAgent:
    """
    Main orchestrator for the unified ReAct agent.
    
    This component coordinates the entire process from user request
    to final response, managing task planning, execution, and confirmation.
    """
    
    def __init__(self):
        self.logger = GenericLogger("core", "agent")
        self.action_planner = ActionPlanner()
        self.service_coordinator = ServiceCoordinator()
        self.confirmation_service = ConfirmationService(self.service_coordinator.tool_router)
        self.task_executor = TaskExecutor(self.service_coordinator, self.confirmation_service)
        self.response_formatter = ResponseFormatter()
        # SessionService„ÅÆ„Ç§„É≥„Éù„Éº„Éà„Å®ÂàùÊúüÂåñ„ÇíËøΩÂä†
        from services.session_service import SessionService
        self.session_service = SessionService()
    
    async def process_request(self, user_request: str, user_id: str, token: str, sse_session_id: Optional[str] = None, is_confirmation_response: bool = False) -> Dict[str, Any]:
        """
        Process user request through the complete ReAct loop.
        
        Args:
            user_request: User's natural language request
            user_id: User identifier
            token: Authentication token
            sse_session_id: Optional SSE session ID for progress tracking
            is_confirmation_response: Whether this is a response to confirmation request
            
        Returns:
            Final response string
        """
        try:
            self.logger.info(f"üéØ [AGENT] Starting request processing for user {user_id}")
            self.logger.info(f"üìù [AGENT] User request: '{user_request}'")
            self.logger.info(f"üîÑ [AGENT] Is confirmation response: {is_confirmation_response}")
            
            # ÊõñÊòßÊÄßËß£Ê±∫„ÅÆÂõûÁ≠î„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if is_confirmation_response and sse_session_id:
                saved_state = await self.session_service.get_confirmation_state(sse_session_id)
                if saved_state:
                    self.logger.info(f"üîÑ [AGENT] Resuming from confirmation")
                    # ActionPlanner„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Å¶„ÄÅ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã„Åã„ÇâÂÜçÈñã
                    return await self._resume_from_confirmation(
                        saved_state, user_request, user_id, token, sse_session_id
                    )
                else:
                    self.logger.warning(f"‚ö†Ô∏è [AGENT] Confirmation response but no saved state found for session: {sse_session_id}")
            
            # Êñ∞„Åó„ÅÑ„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂ†¥Âêà„ÅÆÈÄöÂ∏∏Âá¶ÁêÜ
            
            # Initialize task chain manager
            task_chain_manager = TaskChainManager(sse_session_id)
            self.logger.info(f"üîó [AGENT] TaskChainManager initialized")
            
            # Step 1: Planning - Generate task list
            self.logger.info(f"üìã [AGENT] Starting planning phase...")
            tasks = await self.action_planner.plan(user_request, user_id, sse_session_id)
            
            # Phase 1F: „Çª„ÉÉ„Ç∑„Éß„É≥„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊ≥®ÂÖ•ÔºàËøΩÂä†ÊèêÊ°à„ÅÆÂ†¥ÂêàÔºâ
            if sse_session_id and any(t.parameters.get("inventory_items", "").startswith("session.context.") for t in tasks):
                self.logger.info(f"üîÑ [AGENT] Detected session context references, injecting values")
                for task in tasks:
                    for key, value in task.parameters.items():
                        if isinstance(value, str) and value.startswith("session.context."):
                            context_key = value.replace("session.context.", "")
                            context_value = await self.session_service.get_session_context(
                                sse_session_id, context_key, None
                            )
                            task.parameters[key] = context_value
                            self.logger.info(f"üíæ [AGENT] Injected session context: {context_key} = {context_value}")
            task_chain_manager.set_tasks(tasks)
            self.logger.info(f"‚úÖ [AGENT] Planning phase completed: {len(tasks)} tasks generated")
            
            # Step 2: Execution - Execute tasks
            self.logger.info(f"‚öôÔ∏è [AGENT] Starting execution phase...")
            execution_result = await self.task_executor.execute(
                tasks, user_id, task_chain_manager, token
            )
            self.logger.info(f"‚úÖ [AGENT] Execution phase completed: status={execution_result.status}")
            
            # Step 3: Handle confirmation if needed
            if execution_result.status == "needs_confirmation":
                self.logger.info(f"‚ö†Ô∏è [AGENT] Confirmation required, handling user interaction...")
                confirmation_result = await self._handle_confirmation(
                    execution_result, user_id, task_chain_manager, token, user_request
                )
                
                # Á¢∫Ë™ç„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØËæûÊõ∏„ÇíËøî„Åô
                if confirmation_result.get("requires_confirmation"):
                    # SSEÁµåÁî±„ÅßÁ¢∫Ë™çÊÉÖÂ†±„ÇíÈÄÅ‰ø°
                    task_chain_manager.send_complete(
                        confirmation_result["response"],
                        confirmation_data={
                            "requires_confirmation": True,
                            "confirmation_session_id": confirmation_result["confirmation_session_id"]
                        }
                    )
                    return confirmation_result
                else:
                    # Á¢∫Ë™çÂøúÁ≠î„ÅåÂá¶ÁêÜ„Åï„Çå„ÅüÂæå„ÅÆÈÄöÂ∏∏„É¨„Çπ„Éù„É≥„Çπ
                    return confirmation_result["response"]
            
            # Step 4: Format final response
            if execution_result.status == "success":
                self.logger.info(f"üìÑ [AGENT] Starting response formatting...")
                final_response, menu_data = await self.response_formatter.format(execution_result.outputs, sse_session_id)
                self.logger.info(f"üîç [TrueReactAgent] Menu data received: {menu_data is not None}")
                if menu_data:
                    self.logger.info(f"üìä [TrueReactAgent] Menu data size: {len(str(menu_data))} characters")
                task_chain_manager.send_complete(final_response, menu_data)
                self.logger.info(f"‚úÖ [AGENT] Response formatting completed")
                self.logger.info(f"üéâ [AGENT] Request processing completed successfully")
                
                # ÈÅ∏ÊäûUIÁî®„ÅÆ„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØËæûÊõ∏ÂΩ¢Âºè„ÅßËøî„Åô
                if menu_data and isinstance(menu_data, dict) and menu_data.get("requires_selection"):
                    return {
                        "response": final_response,
                        "requires_selection": menu_data.get("requires_selection", False),
                        "candidates": menu_data.get("candidates"),
                        "task_id": menu_data.get("task_id"),
                        "message": menu_data.get("message", "ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    }
                else:
                    return {"response": final_response}
            else:
                error_msg = f"„Çø„Çπ„ÇØ„ÅÆÂÆüË°å‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {execution_result.message}"
                self.logger.error(f"‚ùå [AGENT] Execution failed: {execution_result.message}")
                return {"response": error_msg}
                
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Request processing failed: {str(e)}")
            return {"response": f"„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"}
    
    async def _handle_confirmation(self, execution_result: ExecutionResult, user_id: str, task_chain_manager: TaskChainManager, token: str, user_request: str) -> dict:
        """Handle confirmation process when ambiguity is detected."""
        try:
            self.logger.info(f"ü§ù [AGENT] Starting confirmation handling for user {user_id}")
            
            # Pause execution for confirmation
            task_chain_manager.pause_for_confirmation()
            self.logger.info(f"‚è∏Ô∏è [AGENT] Execution paused for user confirmation")
            
            # Process confirmation with user
            confirmation_context = execution_result.confirmation_context
            if not confirmation_context:
                self.logger.error(f"‚ùå [AGENT] Confirmation context is missing")
                return {
                    "response": "Á¢∫Ë™çÊÉÖÂ†±„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                    "requires_confirmation": False
                }
            
            # ÂÖÉ„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„Çí‰øùÊåÅ
            ambiguity_info = confirmation_context.get("ambiguity_info")
            original_tasks = confirmation_context.get("original_tasks", [])
            
            # Phase 1E: „Çª„ÉÉ„Ç∑„Éß„É≥„Å´Á¢∫Ë™ç„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí‰øùÂ≠ò
            if task_chain_manager.sse_session_id:
                session = await self.session_service.get_session(task_chain_manager.sse_session_id, user_id)
                if not session:
                    # ÊåáÂÆöID„Åß„Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰ΩúÊàê
                    session = await self.session_service.create_session(user_id, task_chain_manager.sse_session_id)
                    self.logger.info(f"‚úÖ [AGENT] Created new session with ID: {task_chain_manager.sse_session_id}")
                
                confirmation_message = execution_result.message if hasattr(execution_result, 'message') else ""
                session.set_ambiguity_confirmation(
                    original_request=user_request,  # ÂÖÉ„ÅÆ„É¶„Éº„Ç∂„Éº„É™„ÇØ„Ç®„Çπ„Éà
                    question=confirmation_message,  # Á¢∫Ë™çË≥™Âïè
                    ambiguity_details=ambiguity_info.details if hasattr(ambiguity_info, 'details') else {}
                )
                self.logger.info(f"üíæ [AGENT] Confirmation context saved to session")
            
            # Áä∂ÊÖã„Çí‰øùÂ≠ò
            from datetime import datetime
            state_data = {
                'task_chain_manager': task_chain_manager,
                'execution_result': execution_result,
                'original_tasks': original_tasks,
                'ambiguity_info': ambiguity_info,
                'created_at': datetime.now(),
                'user_id': user_id,
                'token': token
            }
            
            await self.session_service.save_confirmation_state(
                task_chain_manager.sse_session_id,
                user_id,
                state_data
            )
            self.logger.info(f"üíæ [AGENT] Confirmation state saved for session: {task_chain_manager.sse_session_id}")
            
            # „É¶„Éº„Ç∂„Éº„Å´Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËøî„ÅôÔºàÊ¨°„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÅßÂÜçÈñãÔºâ
            # ÊõñÊòßÊÄß„ÅÆ„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶ÈÅ©Âàá„Å™„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åô
            if hasattr(ambiguity_info, 'details') and ambiguity_info.details.get("type") == "main_ingredient_optional_selection":
                confirmation_message = self._create_menu_confirmation_message(ambiguity_info)
            else:
                confirmation_message = self._create_confirmation_message(ambiguity_info)
            
            # „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞: ambiguity_info„ÅÆË©≥Á¥∞„ÇíÂá∫Âäõ
            self.logger.info(f"üîç [AGENT] Ambiguity info details: {ambiguity_info.details if hasattr(ambiguity_info, 'details') else 'No details'}")
            self.logger.info(f"üìù [AGENT] Confirmation message: {confirmation_message}")
            
            result_dict = {
                "response": confirmation_message,
                "requires_confirmation": True,
                "confirmation_session_id": task_chain_manager.sse_session_id
            }
            
            # „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞: Êàª„ÇäÂÄ§„ÅÆËæûÊõ∏„ÇíÂá∫Âäõ
            self.logger.info(f"üì§ [AGENT] Returning confirmation result: {result_dict}")
            
            return result_dict
                
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Confirmation handling failed: {str(e)}")
            return {
                "response": f"Á¢∫Ë™çÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}",
                "requires_confirmation": False
            }
    
    async def _resume_from_confirmation(
        self,
        saved_state: Dict[str, Any],
        user_response: str,
        user_id: str,
        token: str,
        sse_session_id: str
    ) -> str:
        """
        ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã„Åã„ÇâÊõñÊòßÊÄßËß£Ê±∫„ÇíÂÜçÈñã
        
        Args:
            saved_state: ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã
            user_response: „É¶„Éº„Ç∂„Éº„ÅÆÂõûÁ≠îÔºà‰æãÔºö„ÄåÊúÄÊñ∞„ÅÆ„Åß„ÅäÈ°ò„ÅÑ„ÄçÔºâ
            user_id: „É¶„Éº„Ç∂„ÉºID
            token: Ë™çË®º„Éà„Éº„ÇØ„É≥
            sse_session_id: SSE„Çª„ÉÉ„Ç∑„Éß„É≥ID
        """
        try:
            self.logger.info(f"üîÑ [AGENT] Resuming from confirmation for session: {sse_session_id}")
            
            # ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã„ÇíÂæ©ÂÖÉ
            task_chain_manager = saved_state['task_chain_manager']
            original_tasks = saved_state['original_tasks']
            ambiguity_info = saved_state['ambiguity_info']
            
            # Phase 1E: ÊõñÊòßÊÄßËß£Ê∂à„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁµ±Âêà„ÇíË°å„ÅÜ
            if hasattr(ambiguity_info, 'details') and ambiguity_info.details.get("type") == "main_ingredient_optional_selection":
                # ÂÖÉ„ÅÆ„É¶„Éº„Ç∂„Éº„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂèñÂæóÔºà„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÔºâ
                session = await self.session_service.get_session(sse_session_id, user_id)
                if session and session.confirmation_context.get("original_request"):
                    original_request = session.confirmation_context.get("original_request")
                    
                    # „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁµ±Âêà
                    integrated_request = await self._integrate_confirmation_response(
                        original_request,
                        user_response,
                        ambiguity_info.details
                    )
                    
                    # Á¢∫Ë™ç„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí„ÇØ„É™„Ç¢
                    session.clear_confirmation_context()
                    
                    # Áµ±Âêà„Åï„Çå„Åü„É™„ÇØ„Ç®„Çπ„Éà„ÅßÈÄöÂ∏∏„ÅÆ„Éó„É©„É≥„Éã„É≥„Ç∞„É´„Éº„Éó„ÇíÂÆüË°å
                    self.logger.info(f"‚ñ∂Ô∏è [AGENT] Resuming planning loop with integrated request: {integrated_request}")
                    result = await self.process_request(integrated_request, user_id, token, sse_session_id, False)
                    return result
            
            # Êó¢Â≠ò„ÅÆÂá¶ÁêÜÔºàÂú®Â∫´Êìç‰ΩúÁ¢∫Ë™çÁ≠âÔºâ
            confirmation_context = {
                'ambiguity_info': ambiguity_info,
                'user_response': user_response,
                'original_tasks': original_tasks
            }
            
            confirmation_result = await self.confirmation_service.process_confirmation(
                ambiguity_info, user_response, confirmation_context, original_tasks
            )
            
            if confirmation_result.is_cancelled:
                await self.session_service.clear_confirmation_state(sse_session_id)
                return "Êìç‰Ωú„ÅØ„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü„ÄÇ"
            
            # „Çø„Çπ„ÇØ„ÇíÊõ¥Êñ∞
            updated_tasks = await self.confirmation_service.maintain_task_chain(
                original_tasks, confirmation_result
            )
            
            # ÂÆüË°åÂÜçÈñã
            task_chain_manager.resume_execution()
            task_chain_manager.set_tasks(updated_tasks)
            
            # ‚òÖ„Åì„Åì„ÅßTaskExecutorÂÜçÂÆüË°åÔºàActionPlanner„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºâ
            final_execution_result = await self.task_executor.execute(
                updated_tasks, user_id, task_chain_manager, token
            )
            
            # Áä∂ÊÖã„Çí„ÇØ„É™„Ç¢
            await self.session_service.clear_confirmation_state(sse_session_id)
            
            # ÊúÄÁµÇ„É¨„Çπ„Éù„É≥„ÇπÁîüÊàê
            if final_execution_result.status == "success":
                final_response, menu_data = await self.response_formatter.format(final_execution_result.outputs, sse_session_id)
                task_chain_manager.send_complete(final_response, menu_data)
                return final_response
            else:
                return f"Á¢∫Ë™çÂæå„ÅÆ„Çø„Çπ„ÇØÂÆüË°å‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {final_execution_result.message}"
        
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Resume from confirmation failed: {e}")
            await self.session_service.clear_confirmation_state(sse_session_id)
            return f"Á¢∫Ë™çÂá¶ÁêÜ„ÅÆÂÜçÈñã‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"
    
    def _create_confirmation_message(self, ambiguity_info) -> str:
        """
        ÊõñÊòßÊÄßÊÉÖÂ†±„Åã„ÇâÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁîüÊàê
        
        Args:
            ambiguity_info: ÊõñÊòßÊÄßÊÉÖÂ†±
            
        Returns:
            Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏
        """
        try:
            if not ambiguity_info:
                return "Ë§áÊï∞„ÅÆÈÅ∏ÊäûËÇ¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÅãÔºü"
            
            # ÊõñÊòßÊÄß„ÅÆË©≥Á¥∞„ÇíÂèñÂæó
            details = ambiguity_info.details if hasattr(ambiguity_info, 'details') else {}
            tool_name = ambiguity_info.tool_name if hasattr(ambiguity_info, 'tool_name') else "Êìç‰Ωú"
            
            # Âú®Â∫´Êìç‰Ωú„ÅÆÂ†¥Âêà„ÅÆÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏
            if tool_name.startswith("inventory_"):
                if 'items' in details:
                    items = details['items']
                    if len(items) > 1:
                        item_name = items[0].get('item_name', '„Ç¢„Ç§„ÉÜ„É†')
                        operation = "ÂâäÈô§" if "delete" in tool_name else "Êõ¥Êñ∞"
                        
                        message = f"„Äå{item_name}„Äç„Åå{len(items)}‰ª∂Ë¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ\n\n"
                        for i, item in enumerate(items, 1):
                            message += f"„Ç¢„Ç§„ÉÜ„É†{i}:\n"
                            if 'quantity' in item:
                                message += f"  Êï∞Èáè: {item['quantity']} {item.get('unit', '')}\n"
                            if 'storage_location' in item and item['storage_location']:
                                message += f"  ‰øùÂ≠òÂ†¥ÊâÄ: {item['storage_location']}\n"
                            if 'expiry_date' in item and item['expiry_date']:
                                message += f"  ÊúüÈôê: {item['expiry_date']}\n"
                            if 'created_at' in item:
                                message += f"  ËøΩÂä†Êó•: {item['created_at']}\n"
                            message += "\n"
                        
                        message += "‰ª•‰∏ã„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n"
                        message += "- „ÄåÊúÄÊñ∞„ÅÆ„Äç„Åæ„Åü„ÅØ„ÄåÊñ∞„Åó„ÅÑ„Äç: ÊúÄ„ÇÇÊúÄËøëËøΩÂä†„Åï„Çå„Åü„ÇÇ„ÅÆ\n"
                        message += "- „ÄåÂè§„ÅÑ„Äç„Åæ„Åü„ÅØ„ÄåÂè§„ÅÑ„ÅÆ„Äç: ÊúÄ„ÇÇÂè§„ÅÑ„ÇÇ„ÅÆ\n"
                        message += "- „ÄåÂÖ®ÈÉ®„Äç„Åæ„Åü„ÅØ„Äå„Åô„Åπ„Å¶„Äç: ÂÖ®„Å¶„ÅÆ„Ç¢„Ç§„ÉÜ„É†\n"
                        message += "- „Äå„Ç≠„É£„É≥„Çª„É´„Äç: Êìç‰Ωú„Çí‰∏≠Ê≠¢"
                        return message
                
                # items„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                return f"Ë§áÊï∞„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ„Å©„Çå„Çí{tool_name.replace('inventory_', '').replace('_', ' ')}„Åó„Åæ„Åô„ÅãÔºü"
            
            # „Éá„Éï„Ç©„É´„Éà„É°„ÉÉ„Çª„Éº„Ç∏
            return "Ë§áÊï∞„ÅÆÈÅ∏ÊäûËÇ¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÅãÔºü"
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Error creating confirmation message: {e}")
            return "Ë§áÊï∞„ÅÆÈÅ∏ÊäûËÇ¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÅãÔºü"
    
    def _create_menu_confirmation_message(self, ambiguity_info) -> str:
        """
        ÁåÆÁ´ãÊèêÊ°à„ÅÆÊõñÊòßÊÄßÊÉÖÂ†±„Åã„ÇâÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁîüÊàê
        
        Args:
            ambiguity_info: ÊõñÊòßÊÄßÊÉÖÂ†±
            
        Returns:
            Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏
        """
        details = ambiguity_info.details if hasattr(ambiguity_info, 'details') else {}
        return details.get("message", "Ë§áÊï∞„ÅÆÈÅ∏ÊäûËÇ¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÅãÔºü")
    
    async def handle_user_selection_required(self, candidates: list, context: dict, task_chain_manager: TaskChainManager) -> dict:
        """„É¶„Éº„Ç∂„ÉºÈÅ∏Êäû„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅÆÂá¶ÁêÜ"""
        try:
            # „Çø„Çπ„ÇØID„ÇíÂèñÂæó
            task_id = context.get('current_task_id')
            if not task_id:
                raise ValueError("No task ID found in context")
            
            # „Çø„Çπ„ÇØ„Çí‰∏ÄÊôÇÂÅúÊ≠¢
            pause_result = task_chain_manager.pause_task_for_user_selection(task_id, context)
            
            if not pause_result["success"]:
                raise Exception(f"Failed to pause task: {pause_result['error']}")
            
            self.logger.info(f"‚è∏Ô∏è [AGENT] Task {task_id} paused for user selection")
            
            # „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å´ÈÅ∏ÊäûË¶ÅÊ±Ç„ÇíÈÄÅ‰ø°
            response = {
                "success": True,
                "requires_selection": True,
                "candidates": candidates,
                "task_id": task_id,
                "message": "‰ª•‰∏ã„ÅÆ5‰ª∂„Åã„ÇâÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:"
            }
            
            return response
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to handle user selection required: {e}")
            return {
                "success": False,
                "error": str(e),
                "requires_selection": False
            }
    
    async def process_user_selection(self, task_id: str, selection: int, sse_session_id: str, user_id: str, token: str, old_sse_session_id: str = None) -> dict:
        """„É¶„Éº„Ç∂„ÉºÈÅ∏ÊäûÁµêÊûú„ÅÆÂá¶ÁêÜÔºàËá™ÂãïÈÅ∑ÁßªÊ©üËÉΩ‰ªò„ÅçÔºâ"""
        try:
            self.logger.info(f"üì• [AGENT] Processing user selection: task_id={task_id}, selection={selection}")
            
            # Phase 1F: selection=0 „ÅÆÂ†¥Âêà„ÅØËøΩÂä†ÊèêÊ°àË¶ÅÊ±Ç
            if selection == 0:
                self.logger.info(f"üîÑ [AGENT] Additional proposal request detected (selection=0)")
                return await self._handle_additional_proposal_request(
                    task_id, sse_session_id, user_id, token, old_sse_session_id
                )
            
            # Phase 3C-2: ÊÆµÈöéÂà§ÂÆö„Å®ÈÄ≤Ë°åÂá¶ÁêÜ
            # ÁèæÂú®„ÅÆÊÆµÈöé„ÇíÂèñÂæó
            current_stage = await self._get_current_stage(sse_session_id, user_id)
            self.logger.info(f"üîç [AGENT] Current stage: {current_stage}")
            
            # „Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂèñÂæó
            session = await self.session_service.get_session(sse_session_id, user_id)
            if not session:
                self.logger.error(f"‚ùå [AGENT] Session not found: {sse_session_id}")
                return {"success": False, "error": "Session not found"}
            
            # ÈÅ∏Êäû„Åï„Çå„Åü„É¨„Ç∑„ÉîÊÉÖÂ†±„ÇíÂèñÂæó
            selected_recipe = await self._get_selected_recipe_from_task(task_id, selection, sse_session_id)
            self.logger.info(f"‚úÖ [AGENT] Selected recipe: {selected_recipe.get('title', 'Unknown')}")
            
            # Phase 3C-3: ÊÆµÈöé„ÇíÈÄ≤„ÇÅ„Çã
            next_stage = await self._advance_stage(sse_session_id, user_id, selected_recipe)
            self.logger.info(f"üîÑ [AGENT] Advanced to stage: {next_stage}")
            
            # Ê¨°„ÅÆÊÆµÈöé„Å´Âøú„Åò„ÅüÂá¶ÁêÜ
            if next_stage == "sub":
                # ÂâØËèúÊèêÊ°à„Å´Ëá™ÂãïÈÅ∑Áßª
                self.logger.info(f"üîÑ [AGENT] Auto-transitioning to sub dish proposal")
                next_request = await self._generate_sub_dish_request(
                    selected_recipe, sse_session_id, user_id
                )
                self.logger.info(f"üìù [AGENT] Generated sub dish request: {next_request}")
                
                # „Çª„ÉÉ„Ç∑„Éß„É≥„Å´Ê¨°„ÅÆÊèêÊ°à„É™„ÇØ„Ç®„Çπ„Éà„Çí‰øùÂ≠òÔºà„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅåË™≠„ÅøÂèñ„ÇãÔºâ
                session.set_context("next_stage_request", next_request)
                self.logger.info(f"üíæ [AGENT] Saved next stage request to session")
                
                # „Éï„É©„Ç∞„ÇíËøî„Åó„Å¶„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å´Ê¨°„ÅÆÊèêÊ°à„ÇíË¶ÅÊ±Ç
                return {
                    "success": True,
                    "message": "‰∏ªËèú„ÅåÁ¢∫ÂÆö„Åó„Åæ„Åó„Åü„ÄÇÂâØËèú„ÇíÊèêÊ°à„Åó„Åæ„Åô„ÄÇ",
                    "requires_next_stage": True
                }
            
            elif next_stage == "soup":
                # Ê±ÅÁâ©ÊèêÊ°à„Å´Ëá™ÂãïÈÅ∑Áßª
                self.logger.info(f"üîÑ [AGENT] Auto-transitioning to soup proposal")
                next_request = await self._generate_soup_request(
                    selected_recipe, sse_session_id, user_id
                )
                self.logger.info(f"üìù [AGENT] Generated soup request: {next_request}")
                
                # „Çª„ÉÉ„Ç∑„Éß„É≥„Å´Ê¨°„ÅÆÊèêÊ°à„É™„ÇØ„Ç®„Çπ„Éà„Çí‰øùÂ≠òÔºà„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅåË™≠„ÅøÂèñ„ÇãÔºâ
                session.set_context("next_stage_request", next_request)
                self.logger.info(f"üíæ [AGENT] Saved next stage request to session")
                
                # „Éï„É©„Ç∞„ÇíËøî„Åó„Å¶„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å´Ê¨°„ÅÆÊèêÊ°à„ÇíË¶ÅÊ±Ç
                return {
                    "success": True,
                    "message": "ÂâØËèú„ÅåÁ¢∫ÂÆö„Åó„Åæ„Åó„Åü„ÄÇÊ±ÅÁâ©„ÇíÊèêÊ°à„Åó„Åæ„Åô„ÄÇ",
                    "requires_next_stage": True
                }
            
            elif next_stage == "completed":
                # ÂÆå‰∫Ü
                self.logger.info(f"‚úÖ [AGENT] All stages completed")
                sub_dish = await self._get_selected_sub_dish(sse_session_id, user_id)
                soup = await self._get_selected_soup(sse_session_id, user_id)
                
                return {
                    "success": True,
                    "message": "ÁåÆÁ´ã„ÅåÂÆåÊàê„Åó„Åæ„Åó„Åü„ÄÇ",
                    "menu": {
                        "main": selected_recipe,
                        "sub": sub_dish,
                        "soup": soup
                    }
                }
            
            # „Åù„ÅÆ‰ªñ„ÅÆÂ†¥ÂêàÔºàÈÄöÂ∏∏„ÅÆÈÅ∏ÊäûÂá¶ÁêÜÔºâ
            self.logger.info(f"‚úÖ [AGENT] Selection {selection} processed for stage {current_stage}")
            
            return {
                "success": True,
                "task_id": task_id,
                "selection": selection,
                "current_stage": current_stage,
                "message": f"ÈÅ∏ÊäûËÇ¢ {selection} „ÇíÂèó„Åë‰ªò„Åë„Åæ„Åó„Åü„ÄÇ"
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to process user selection: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _handle_additional_proposal_request(
        self, 
        task_id: str,
        sse_session_id: str, 
        user_id: str, 
        token: str,
        old_sse_session_id: str = None
    ) -> dict:
        """ËøΩÂä†ÊèêÊ°àË¶ÅÊ±Ç„ÅÆÂá¶ÁêÜÔºàselection=0„ÅÆÂ†¥ÂêàÔºâ
        
        Args:
            task_id: „Çø„Çπ„ÇØID
            sse_session_id: Êñ∞„Åó„ÅÑSSE„Çª„ÉÉ„Ç∑„Éß„É≥ID
            user_id: „É¶„Éº„Ç∂„ÉºID
            token: Ë™çË®º„Éà„Éº„ÇØ„É≥
            old_sse_session_id: ÊóßSSE„Çª„ÉÉ„Ç∑„Éß„É≥IDÔºà„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÂæ©ÂÖÉÁî®Ôºâ
        
        Returns:
            dict: Âá¶ÁêÜÁµêÊûú
        """
        try:
            self.logger.info(f"üîÑ [AGENT] Handling additional proposal request")
            self.logger.info(f"üîç [AGENT] New SSE session ID: {sse_session_id}")
            self.logger.info(f"üîç [AGENT] Old SSE session ID: {old_sse_session_id}")
            
            # Êóß„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„Çâ‰∏ªË¶ÅÈ£üÊùê„ÇíÂèñÂæóÔºà„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÂæ©ÂÖÉÔºâ
            main_ingredient = None
            if old_sse_session_id:
                old_session = await self.session_service.get_session(old_sse_session_id, user_id)
                if old_session:
                    main_ingredient = old_session.get_context("main_ingredient")
                    inventory_items = old_session.get_context("inventory_items")
                    menu_type = old_session.get_context("menu_type")
                    
                    # Êóß„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÊèêÊ°àÊ∏à„Åø„Çø„Ç§„Éà„É´„ÇíÂèñÂæó
                    proposed_titles = old_session.get_proposed_recipes("main")
                    self.logger.info(f"üîç [AGENT] Retrieved from old session: main_ingredient={main_ingredient}, proposed_titles count={len(proposed_titles)}")
                    
                    # Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Å´„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí„Ç≥„Éî„Éº
                    new_session = await self.session_service.get_session(sse_session_id, user_id)
                    if not new_session:
                        new_session = await self.session_service.create_session(user_id, sse_session_id)
                    
                    new_session.set_context("main_ingredient", main_ingredient)
                    new_session.set_context("inventory_items", inventory_items)
                    new_session.set_context("menu_type", menu_type)
                    
                    # ÊèêÊ°àÊ∏à„Åø„Çø„Ç§„Éà„É´„ÇÇÊñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Å´„Ç≥„Éî„Éº
                    if proposed_titles:
                        new_session.add_proposed_recipes("main", proposed_titles)
                        self.logger.info(f"‚úÖ [AGENT] Copied {len(proposed_titles)} proposed titles to new session")
                    
                    self.logger.info(f"‚úÖ [AGENT] Copied context from old session to new session")
            
            # ‰∏ªË¶ÅÈ£üÊùê„ÅåÂèñÂæó„Åß„Åç„Åü„ÅãÁ¢∫Ë™ç
            if not main_ingredient:
                # Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÂèñÂæó„ÇíË©¶„Åø„Çã
                session = await self.session_service.get_session(sse_session_id, user_id)
                if session:
                    main_ingredient = session.get_context("main_ingredient")
                
                if not main_ingredient:
                    self.logger.warning(f"‚ö†Ô∏è [AGENT] main_ingredient not found, using default request")
                    additional_request = "‰∏ªËèú„Çí„ÇÇ„ÅÜ5‰ª∂ÊèêÊ°à„Åó„Å¶"
                else:
                    additional_request = f"{main_ingredient}„ÅÆ‰∏ªËèú„Çí„ÇÇ„ÅÜ5‰ª∂ÊèêÊ°à„Åó„Å¶"
            else:
                additional_request = f"{main_ingredient}„ÅÆ‰∏ªËèú„Çí„ÇÇ„ÅÜ5‰ª∂ÊèêÊ°à„Åó„Å¶"
            
            self.logger.info(f"üìù [AGENT] Final additional request: {additional_request}")
            
            # „Éó„É©„É≥„Éã„É≥„Ç∞„É´„Éº„Éó„ÇíÂÆüË°å
            # ÈáçË¶Å: ËøΩÂä†ÊèêÊ°à„ÅÆÂ†¥Âêà„ÅØ„ÄÅÊñ∞„Åó„ÅÑSSE„Çª„ÉÉ„Ç∑„Éß„É≥IDÔºàadditional-*„ÅßÂßã„Åæ„ÇãÔºâ„Çí‰ΩøÁî®
            # „Åì„Çå„Å´„Çà„Çä„ÄÅÊñ∞„Åó„ÅÑSSEÊé•Á∂ö„ÅåÁ¢∫Á´ã„Åï„Çå„ÄÅÈÄöÂ∏∏„ÅÆ„Çø„Çπ„ÇØÈÄ≤ÊçóÔºàÈÄ≤Êçó„Éê„ÉºÁ≠âÔºâ„Åå„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å´Ë°®Á§∫„Åï„Çå„Çã
            self.logger.info(f"üîÑ [AGENT] Processing additional proposal with SSE session: {sse_session_id}")
            
            result = await self.process_request(
                additional_request, 
                user_id, 
                token, 
                sse_session_id,  # Êñ∞„Åó„ÅÑSSE„Çª„ÉÉ„Ç∑„Éß„É≥IDÔºà„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Åã„ÇâÊ∏°„Åï„Çå„ÇãÔºâ
                is_confirmation_response=False
            )
            
            # Phase 1F: ËøΩÂä†ÊèêÊ°à„ÅÆÂ†¥Âêà„ÄÅSSEÁµåÁî±„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÈÄÅ‰ø°„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ
            # „Åì„Åì„ÅßËøî„ÅôÂÄ§„ÅØ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å´Ë°®Á§∫„Åï„Çå„Å™„ÅÑÔºàÊó¢„Å´SSEÁµåÁî±„ÅßÈÄÅ‰ø°Ê∏à„ÅøÔºâ
            # „Åó„Åã„Åó„ÄÅAPI„ÅÆËøîÂç¥ÂÄ§„ÇíË™øÊï¥
            if isinstance(result, dict):
                # SSEÁµåÁî±„ÅßÈÄÅ‰ø°Ê∏à„Åø„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ‰∏çË¶Å„Å™„Åü„ÇÅÁ©∫„ÅÆËæûÊõ∏„ÇíËøî„Åô
                result["success"] = True
                return result
            else:
                # ËæûÊõ∏‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÅØËæûÊõ∏ÂΩ¢Âºè„Å´Â§âÊèõ
                return {
                    "success": True,
                    "response": str(result)
                }
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to handle additional proposal request: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _integrate_confirmation_response(
        self, 
        original_request: str,  # „Äå‰∏ªËèú„ÇíÊïô„Åà„Å¶„Äç
        user_response: str,     # „Äå„É¨„É≥„Ç≥„É≥„Åß„ÅäÈ°ò„ÅÑ„Äç
        confirmation_context: Dict[str, Any]  # Á¢∫Ë™çÊôÇ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
    ) -> str:
        """
        ÂÖÉ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Å®„É¶„Éº„Ç∂„ÉºÂõûÁ≠î„ÇíÁµ±Âêà„Åó„Å¶„ÄÅ
        ÂÆåÂÖ®„Å™„É™„ÇØ„Ç®„Çπ„Éà„ÇíÁîüÊàê„Åô„Çã
        
        ‰æã:
        - ÂÖÉ: „Äå‰∏ªËèú„ÇíÊïô„Åà„Å¶„Äç
        - ÂõûÁ≠î: „Äå„É¨„É≥„Ç≥„É≥„Åß„ÅäÈ°ò„ÅÑ„Äç
        - ÁµêÊûú: „Äå„É¨„É≥„Ç≥„É≥„ÅÆ‰∏ªËèú„ÇíÊïô„Åà„Å¶„Äç
        """
        
        self.logger.info(f"üîó [AGENT] Integrating request")
        self.logger.info(f"  Original: {original_request}")
        self.logger.info(f"  Response: {user_response}")
        
        # „Éë„Çø„Éº„É≥1: „ÄåÊåáÂÆö„Åó„Å™„ÅÑ„ÄçÁ≥ª„ÅÆÂõûÁ≠î
        proceed_keywords = ["„ÅÑ„ÅÑ„Åà", "„Åù„ÅÆ„Åæ„Åæ", "ÊèêÊ°à„Åó„Å¶", "Âú®Â∫´„Åã„Çâ", "„Åì„ÅÆ„Åæ„Åæ", "ÈÄ≤„ÇÅ„Å¶", "ÊåáÂÆö„Åó„Å™„ÅÑ", "2"]
        if any(keyword in user_response for keyword in proceed_keywords):
            # ÂÖÉ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
            integrated_request = original_request
            self.logger.info(f"‚úÖ [AGENT] Integrated (proceed): {integrated_request}")
            return integrated_request
        
        # „Éë„Çø„Éº„É≥2: È£üÊùêÂêç„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã
        # Á∞°ÊòìÁöÑ„Å™Áµ±ÂêàÔºàLLM„Çí‰Ωø„Çè„Å™„ÅÑÊñπÂºèÔºâ
        # „Äå„É¨„É≥„Ç≥„É≥„Äç„Äå„É¨„É≥„Ç≥„É≥„Åß„Äç„Äå„É¨„É≥„Ç≥„É≥„Çí‰Ωø„Å£„Å¶„ÄçÁ≠â„ÇíÊäΩÂá∫
        ingredient = self._extract_ingredient_simple(user_response)
        
        if ingredient:
            # ÂÖÉ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Å´È£üÊùê„ÇíËøΩÂä†
            # „Äå‰∏ªËèú„ÇíÊïô„Åà„Å¶„Äç‚Üí„Äå„É¨„É≥„Ç≥„É≥„ÅÆ‰∏ªËèú„ÇíÊïô„Åà„Å¶„Äç
            if "‰∏ªËèú" in original_request or "„É°„Ç§„É≥" in original_request:
                integrated_request = f"{ingredient}„ÅÆ‰∏ªËèú„ÇíÊïô„Åà„Å¶"
            elif "ÊñôÁêÜ" in original_request:
                integrated_request = f"{ingredient}„ÅÆÊñôÁêÜ„ÇíÊïô„Åà„Å¶"
            else:
                integrated_request = f"{ingredient}„Çí‰Ωø„Å£„Å¶{original_request}"
            
            self.logger.info(f"‚úÖ [AGENT] Integrated (ingredient): {integrated_request}")
            return integrated_request
        
        # „Éë„Çø„Éº„É≥3: Áµ±Âêà„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíËøî„Åô
        self.logger.warning(f"‚ö†Ô∏è [AGENT] Could not integrate, using original request")
        return original_request
    
    def _extract_ingredient_simple(self, user_response: str) -> Optional[str]:
        """„É¶„Éº„Ç∂„ÉºÂøúÁ≠î„Åã„ÇâÈ£üÊùêÂêç„ÇíÁ∞°ÊòìÊäΩÂá∫"""
        
        # Âä©Ë©û„ÇíÈô§Âéª
        cleaned = user_response.replace("„Åß", "").replace("„Çí", "").replace("„Åå", "")
        cleaned = cleaned.replace("‰Ωø„Å£„Å¶", "").replace("„ÅäÈ°ò„ÅÑ", "").replace("„Åè„Å†„Åï„ÅÑ", "")
        cleaned = cleaned.strip()
        
        # Á©∫„Åß„Å™„Åë„Çå„Å∞È£üÊùêÂêç„Å®„Åó„Å¶Êâ±„ÅÜ
        if cleaned and len(cleaned) > 0:
            return cleaned
        
        return None
    
    async def _get_current_stage(self, sse_session_id: str, user_id: str) -> str:
        """ÁèæÂú®„ÅÆÊÆµÈöé„ÇíÂèñÂæó
        
        Args:
            sse_session_id: SSE„Çª„ÉÉ„Ç∑„Éß„É≥ID
            user_id: „É¶„Éº„Ç∂„ÉºID
        
        Returns:
            str: ÁèæÂú®„ÅÆÊÆµÈöéÔºà"main", "sub", "soup", "completed"Ôºâ
        """
        try:
            session = await self.session_service.get_session(sse_session_id, user_id)
            if not session:
                self.logger.warning(f"‚ö†Ô∏è [AGENT] Session not found, returning default stage 'main'")
                return "main"
            
            stage = session.get_current_stage()
            self.logger.info(f"‚úÖ [AGENT] Current stage: {stage}")
            return stage
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to get current stage: {e}")
            return "main"
    
    async def _get_selected_recipe_from_task(self, task_id: str, selection: int, sse_session_id: str) -> Dict[str, Any]:
        """ÈÅ∏Êäû„Åï„Çå„Åü„É¨„Ç∑„Éî„Çí„Çø„Çπ„ÇØ„Åã„ÇâÂèñÂæó
        
        Args:
            task_id: „Çø„Çπ„ÇØID
            selection: ÈÅ∏Êäû„Åï„Çå„Åü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
            sse_session_id: SSE„Çª„ÉÉ„Ç∑„Éß„É≥ID
        
        Returns:
            Dict[str, Any]: ÈÅ∏Êäû„Åï„Çå„Åü„É¨„Ç∑„ÉîÊÉÖÂ†±
        """
        try:
            self.logger.info(f"üîç [AGENT] Getting selected recipe: task_id={task_id}, selection={selection}")
            
            # „Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÂÄôË£úÊÉÖÂ†±„ÇíÂèñÂæó
            session = await self.session_service.get_session(sse_session_id, user_id=None)
            if not session:
                self.logger.error(f"‚ùå [AGENT] Session not found: {sse_session_id}")
                return {}
            
            # ÁèæÂú®„ÅÆÊÆµÈöé„ÇíÂèñÂæó
            current_stage = session.get_current_stage()
            category = current_stage  # "main", "sub", "soup"
            
            # „Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÇâÂÄôË£úÊÉÖÂ†±„ÇíÂèñÂæó
            candidates = session.get_candidates(category)
            if not candidates or len(candidates) < selection:
                self.logger.error(f"‚ùå [AGENT] Invalid selection: {selection} for {len(candidates)} candidates")
                return {}
            
            # ÈÅ∏Êäû„Åï„Çå„Åü„É¨„Ç∑„Éî„ÇíÂèñÂæó
            selected_recipe = candidates[selection - 1]  # „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅØ1„Éô„Éº„Çπ
            self.logger.info(f"‚úÖ [AGENT] Selected recipe: {selected_recipe.get('title', 'Unknown')}")
            
            return selected_recipe
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to get selected recipe: {e}")
            return {}
    
    async def _advance_stage(self, sse_session_id: str, user_id: str, selected_recipe: Dict[str, Any]) -> str:
        """ÊÆµÈöé„ÇíÈÄ≤„ÇÅ„Çã
        
        Args:
            sse_session_id: SSE„Çª„ÉÉ„Ç∑„Éß„É≥ID
            user_id: „É¶„Éº„Ç∂„ÉºID
            selected_recipe: ÈÅ∏Êäû„Åï„Çå„Åü„É¨„Ç∑„ÉîÊÉÖÂ†±
        
        Returns:
            str: Ê¨°„ÅÆÊÆµÈöé„ÅÆÂêçÂâç
        """
        try:
            # „Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂèñÂæó
            session = await self.session_service.get_session(sse_session_id, user_id)
            if not session:
                self.logger.error(f"‚ùå [AGENT] Session not found")
                return "main"
            
            # ÁèæÂú®„ÅÆÊÆµÈöé„ÇíÂèñÂæó
            current_stage = session.get_current_stage()
            self.logger.info(f"üîç [AGENT] Current stage: {current_stage}")
            
            # ÊÆµÈöé„Å´Âøú„Åò„Å¶Âá¶ÁêÜ
            if current_stage == "main":
                # ‰∏ªËèú„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà„ÄÅÂâØËèúÊÆµÈöé„Å´ÈÄ≤„ÇÄ
                session.set_selected_recipe("main", selected_recipe)
                next_stage = "sub"
                self.logger.info(f"‚úÖ [AGENT] Advanced to stage: sub")
                
            elif current_stage == "sub":
                # ÂâØËèú„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà„ÄÅÊ±ÅÁâ©ÊÆµÈöé„Å´ÈÄ≤„ÇÄ
                session.set_selected_recipe("sub", selected_recipe)
                next_stage = "soup"
                self.logger.info(f"‚úÖ [AGENT] Advanced to stage: soup")
                
            elif current_stage == "soup":
                # Ê±ÅÁâ©„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà„ÄÅÂÆå‰∫Ü
                session.set_selected_recipe("soup", selected_recipe)
                next_stage = "completed"
                self.logger.info(f"‚úÖ [AGENT] Completed all stages")
                
            else:
                self.logger.warning(f"‚ö†Ô∏è [AGENT] Unexpected stage: {current_stage}")
                next_stage = current_stage
            
            return next_stage
            
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to advance stage: {e}")
            return "main"
    
    async def _generate_sub_dish_request(
        self, main_dish: Dict, sse_session_id: str, user_id: str
    ) -> str:
        """
        ÂâØËèúÊèêÊ°àÁî®„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÁîüÊàê
        
        ‰æã: "ÂâØËèú„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶"Ôºà‰∏ªËèú„Åß‰Ωø„Å£„ÅüÈ£üÊùê„ÇíÈô§Â§ñÔºâ
        """
        session = await self.session_service.get_session(sse_session_id, user_id)
        if not session:
            return "ÂâØËèú„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶"
        
        used_ingredients = session.get_used_ingredients()
        main_ingredient_text = f"Ôºà‰∏ªËèú„Åß‰Ωø„Å£„ÅüÈ£üÊùê: {', '.join(used_ingredients)} „ÅØÈô§Â§ñ„Åó„Å¶Ôºâ"
        
        return f"‰∏ªËèú„Åß‰Ωø„Å£„Å¶„ÅÑ„Å™„ÅÑÈ£üÊùê„ÅßÂâØËèú„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶„ÄÇ{main_ingredient_text}"
    
    async def _generate_soup_request(
        self, sub_dish: Dict, sse_session_id: str, user_id: str
    ) -> str:
        """
        Ê±ÅÁâ©ÊèêÊ°àÁî®„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÁîüÊàê
        
        ‰æã: "Ê±ÅÁâ©„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶"ÔºàÂíåÈ£ü„Å™„ÇâÂë≥ÂôåÊ±Å„ÄÅÊ¥ãÈ£ü„Å™„Çâ„Çπ„Éº„ÉóÔºâ
        """
        session = await self.session_service.get_session(sse_session_id, user_id)
        if not session:
            return "Ê±ÅÁâ©„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶"
        
        used_ingredients = session.get_used_ingredients()
        menu_category = session.get_menu_category()
        
        soup_type = "Âë≥ÂôåÊ±Å" if menu_category == "japanese" else "„Çπ„Éº„Éó"
        used_ingredients_text = f"Ôºà‰∏ªËèú„ÉªÂâØËèú„Åß‰Ωø„Å£„ÅüÈ£üÊùê: {', '.join(used_ingredients)} „ÅØÈô§Â§ñ„Åó„Å¶Ôºâ"
        
        return f"{soup_type}„Çí5‰ª∂ÊèêÊ°à„Åó„Å¶„ÄÇ{used_ingredients_text}"
    
    async def _get_selected_sub_dish(self, sse_session_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """ÈÅ∏ÊäûÊ∏à„ÅøÂâØËèú„ÇíÂèñÂæó"""
        try:
            session = await self.session_service.get_session(sse_session_id, user_id)
            if session:
                return session.selected_sub_dish
            return None
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to get selected sub dish: {e}")
            return None
    
    async def _get_selected_soup(self, sse_session_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """ÈÅ∏ÊäûÊ∏à„ÅøÊ±ÅÁâ©„ÇíÂèñÂæó"""
        try:
            session = await self.session_service.get_session(sse_session_id, user_id)
            if session:
                return session.selected_soup
            return None
        except Exception as e:
            self.logger.error(f"‚ùå [AGENT] Failed to get selected soup: {e}")
            return None